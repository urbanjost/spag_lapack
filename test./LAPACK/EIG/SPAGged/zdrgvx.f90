!*==zdrgvx.f90  processed by SPAG 7.51RB at 20:37 on  3 Mar 2022
!> \brief \b ZDRGVX
!
!  =========== DOCUMENTATION ===========
!
! Online html documentation available at
!            http://www.netlib.org/lapack/explore-html/
!
!  Definition:
!  ===========
!
!       SUBROUTINE ZDRGVX( NSIZE, THRESH, NIN, NOUT, A, LDA, B, AI, BI,
!                          ALPHA, BETA, VL, VR, ILO, IHI, LSCALE, RSCALE,
!                          S, DTRU, DIF, DIFTRU, WORK, LWORK, RWORK,
!                          IWORK, LIWORK, RESULT, BWORK, INFO )
!
!       .. Scalar Arguments ..
!       INTEGER            IHI, ILO, INFO, LDA, LIWORK, LWORK, NIN, NOUT,
!      $                   NSIZE
!       DOUBLE PRECISION   THRESH
!       ..
!       .. Array Arguments ..
!       LOGICAL            BWORK( * )
!       INTEGER            IWORK( * )
!       DOUBLE PRECISION   DIF( * ), DIFTRU( * ), DTRU( * ), LSCALE( * ),
!      $                   RESULT( 4 ), RSCALE( * ), RWORK( * ), S( * )
!       COMPLEX*16         A( LDA, * ), AI( LDA, * ), ALPHA( * ),
!      $                   B( LDA, * ), BETA( * ), BI( LDA, * ),
!      $                   VL( LDA, * ), VR( LDA, * ), WORK( * )
!       ..
!
!
!> \par Purpose:
!  =============
!>
!> \verbatim
!>
!> ZDRGVX checks the nonsymmetric generalized eigenvalue problem
!> expert driver ZGGEVX.
!>
!> ZGGEVX computes the generalized eigenvalues, (optionally) the left
!> and/or right eigenvectors, (optionally) computes a balancing
!> transformation to improve the conditioning, and (optionally)
!> reciprocal condition numbers for the eigenvalues and eigenvectors.
!>
!> When ZDRGVX is called with NSIZE > 0, two types of test matrix pairs
!> are generated by the subroutine DLATM6 and test the driver ZGGEVX.
!> The test matrices have the known exact condition numbers for
!> eigenvalues. For the condition numbers of the eigenvectors
!> corresponding the first and last eigenvalues are also know
!> ``exactly'' (see ZLATM6).
!> For each matrix pair, the following tests will be performed and
!> compared with the threshold THRESH.
!>
!> (1) max over all left eigenvalue/-vector pairs (beta/alpha,l) of
!>
!>    | l**H * (beta A - alpha B) | / ( ulp max( |beta A|, |alpha B| ) )
!>
!>     where l**H is the conjugate tranpose of l.
!>
!> (2) max over all right eigenvalue/-vector pairs (beta/alpha,r) of
!>
!>       | (beta A - alpha B) r | / ( ulp max( |beta A|, |alpha B| ) )
!>
!> (3) The condition number S(i) of eigenvalues computed by ZGGEVX
!>     differs less than a factor THRESH from the exact S(i) (see
!>     ZLATM6).
!>
!> (4) DIF(i) computed by ZTGSNA differs less than a factor 10*THRESH
!>     from the exact value (for the 1st and 5th vectors only).
!>
!> Test Matrices
!> =============
!>
!> Two kinds of test matrix pairs
!>          (A, B) = inverse(YH) * (Da, Db) * inverse(X)
!> are used in the tests:
!>
!> 1: Da = 1+a   0    0    0    0    Db = 1   0   0   0   0
!>          0   2+a   0    0    0         0   1   0   0   0
!>          0    0   3+a   0    0         0   0   1   0   0
!>          0    0    0   4+a   0         0   0   0   1   0
!>          0    0    0    0   5+a ,      0   0   0   0   1 , and
!>
!> 2: Da =  1   -1    0    0    0    Db = 1   0   0   0   0
!>          1    1    0    0    0         0   1   0   0   0
!>          0    0    1    0    0         0   0   1   0   0
!>          0    0    0   1+a  1+b        0   0   0   1   0
!>          0    0    0  -1-b  1+a ,      0   0   0   0   1 .
!>
!> In both cases the same inverse(YH) and inverse(X) are used to compute
!> (A, B), giving the exact eigenvectors to (A,B) as (YH, X):
!>
!> YH:  =  1    0   -y    y   -y    X =  1   0  -x  -x   x
!>         0    1   -y    y   -y         0   1   x  -x  -x
!>         0    0    1    0    0         0   0   1   0   0
!>         0    0    0    1    0         0   0   0   1   0
!>         0    0    0    0    1,        0   0   0   0   1 , where
!>
!> a, b, x and y will have all values independently of each other from
!> { sqrt(sqrt(ULP)),  0.1,  1,  10,  1/sqrt(sqrt(ULP)) }.
!> \endverbatim
!
!  Arguments:
!  ==========
!
!> \param[in] NSIZE
!> \verbatim
!>          NSIZE is INTEGER
!>          The number of sizes of matrices to use.  NSIZE must be at
!>          least zero. If it is zero, no randomly generated matrices
!>          are tested, but any test matrices read from NIN will be
!>          tested.  If it is not zero, then N = 5.
!> \endverbatim
!>
!> \param[in] THRESH
!> \verbatim
!>          THRESH is DOUBLE PRECISION
!>          A test will count as "failed" if the "error", computed as
!>          described above, exceeds THRESH.  Note that the error
!>          is scaled to be O(1), so THRESH should be a reasonably
!>          small multiple of 1, e.g., 10 or 100.  In particular,
!>          it should not depend on the precision (single vs. double)
!>          or the size of the matrix.  It must be at least zero.
!> \endverbatim
!>
!> \param[in] NIN
!> \verbatim
!>          NIN is INTEGER
!>          The FORTRAN unit number for reading in the data file of
!>          problems to solve.
!> \endverbatim
!>
!> \param[in] NOUT
!> \verbatim
!>          NOUT is INTEGER
!>          The FORTRAN unit number for printing out error messages
!>          (e.g., if a routine returns IINFO not equal to 0.)
!> \endverbatim
!>
!> \param[out] A
!> \verbatim
!>          A is COMPLEX*16 array, dimension (LDA, NSIZE)
!>          Used to hold the matrix whose eigenvalues are to be
!>          computed.  On exit, A contains the last matrix actually used.
!> \endverbatim
!>
!> \param[in] LDA
!> \verbatim
!>          LDA is INTEGER
!>          The leading dimension of A, B, AI, BI, Ao, and Bo.
!>          It must be at least 1 and at least NSIZE.
!> \endverbatim
!>
!> \param[out] B
!> \verbatim
!>          B is COMPLEX*16 array, dimension (LDA, NSIZE)
!>          Used to hold the matrix whose eigenvalues are to be
!>          computed.  On exit, B contains the last matrix actually used.
!> \endverbatim
!>
!> \param[out] AI
!> \verbatim
!>          AI is COMPLEX*16 array, dimension (LDA, NSIZE)
!>          Copy of A, modified by ZGGEVX.
!> \endverbatim
!>
!> \param[out] BI
!> \verbatim
!>          BI is COMPLEX*16 array, dimension (LDA, NSIZE)
!>          Copy of B, modified by ZGGEVX.
!> \endverbatim
!>
!> \param[out] ALPHA
!> \verbatim
!>          ALPHA is COMPLEX*16 array, dimension (NSIZE)
!> \endverbatim
!>
!> \param[out] BETA
!> \verbatim
!>          BETA is COMPLEX*16 array, dimension (NSIZE)
!>
!>          On exit, ALPHA/BETA are the eigenvalues.
!> \endverbatim
!>
!> \param[out] VL
!> \verbatim
!>          VL is COMPLEX*16 array, dimension (LDA, NSIZE)
!>          VL holds the left eigenvectors computed by ZGGEVX.
!> \endverbatim
!>
!> \param[out] VR
!> \verbatim
!>          VR is COMPLEX*16 array, dimension (LDA, NSIZE)
!>          VR holds the right eigenvectors computed by ZGGEVX.
!> \endverbatim
!>
!> \param[out] ILO
!> \verbatim
!>  		ILO is INTEGER
!> \endverbatim
!>
!> \param[out] IHI
!> \verbatim
!>  		IHI is INTEGER
!> \endverbatim
!>
!> \param[out] LSCALE
!> \verbatim
!>  		LSCALE is DOUBLE PRECISION array, dimension (N)
!> \endverbatim
!>
!> \param[out] RSCALE
!> \verbatim
!>  		RSCALE is DOUBLE PRECISION array, dimension (N)
!> \endverbatim
!>
!> \param[out] S
!> \verbatim
!>  		S is DOUBLE PRECISION array, dimension (N)
!> \endverbatim
!>
!> \param[out] DTRU
!> \verbatim
!>  		DTRU is DOUBLE PRECISION array, dimension (N)
!> \endverbatim
!>
!> \param[out] DIF
!> \verbatim
!>  		DIF is DOUBLE PRECISION array, dimension (N)
!> \endverbatim
!>
!> \param[out] DIFTRU
!> \verbatim
!>  		DIFTRU is DOUBLE PRECISION array, dimension (N)
!> \endverbatim
!>
!> \param[out] WORK
!> \verbatim
!>          WORK is COMPLEX*16 array, dimension (LWORK)
!> \endverbatim
!>
!> \param[in] LWORK
!> \verbatim
!>          LWORK is INTEGER
!>          Leading dimension of WORK.  LWORK >= 2*N*N + 2*N
!> \endverbatim
!>
!> \param[out] RWORK
!> \verbatim
!>          RWORK is DOUBLE PRECISION array, dimension (6*N)
!> \endverbatim
!>
!> \param[out] IWORK
!> \verbatim
!>          IWORK is INTEGER array, dimension (LIWORK)
!> \endverbatim
!>
!> \param[in] LIWORK
!> \verbatim
!>          LIWORK is INTEGER
!>          Leading dimension of IWORK.  LIWORK >= N+2.
!> \endverbatim
!>
!> \param[out] RESULT
!> \verbatim
!>  		RESULT is DOUBLE PRECISION array, dimension (4)
!> \endverbatim
!>
!> \param[out] BWORK
!> \verbatim
!>          BWORK is LOGICAL array, dimension (N)
!> \endverbatim
!>
!> \param[out] INFO
!> \verbatim
!>          INFO is INTEGER
!>          = 0:  successful exit
!>          < 0:  if INFO = -i, the i-th argument had an illegal value.
!>          > 0:  A routine returned an error code.
!> \endverbatim
!
!  Authors:
!  ========
!
!> \author Univ. of Tennessee
!> \author Univ. of California Berkeley
!> \author Univ. of Colorado Denver
!> \author NAG Ltd.
!
!> \date June 2016
!
!> \ingroup complex16_eig
!
!  =====================================================================
      SUBROUTINE ZDRGVX(Nsize,Thresh,Nin,Nout,A,Lda,B,Ai,Bi,Alpha,Beta, &
     &                  Vl,Vr,Ilo,Ihi,Lscale,Rscale,S,Dtru,Dif,Diftru,  &
     &                  Work,Lwork,Rwork,Iwork,Liwork,Result,Bwork,Info)
      IMPLICIT NONE
!*--ZDRGVX300
!
!  -- LAPACK test routine (version 3.7.0) --
!  -- LAPACK is a software package provided by Univ. of Tennessee,    --
!  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--
!     June 2016
!
!     .. Scalar Arguments ..
      INTEGER Ihi , Ilo , Info , Lda , Liwork , Lwork , Nin , Nout ,    &
     &        Nsize
      DOUBLE PRECISION Thresh
!     ..
!     .. Array Arguments ..
      LOGICAL Bwork(*)
      INTEGER Iwork(*)
      DOUBLE PRECISION Dif(*) , Diftru(*) , Dtru(*) , Lscale(*) ,       &
     &                 Result(4) , Rscale(*) , Rwork(*) , S(*)
      COMPLEX*16 A(Lda,*) , Ai(Lda,*) , Alpha(*) , B(Lda,*) , Beta(*) , &
     &           Bi(Lda,*) , Vl(Lda,*) , Vr(Lda,*) , Work(*)
!     ..
!
!  =====================================================================
!
!     .. Parameters ..
      DOUBLE PRECISION ZERO , ONE , TEN , TNTH , HALF
      PARAMETER (ZERO=0.0D+0,ONE=1.0D+0,TEN=1.0D+1,TNTH=1.0D-1,         &
     &           HALF=0.5D+0)
!     ..
!     .. Local Scalars ..
      INTEGER i , iptype , iwa , iwb , iwx , iwy , j , linfo , maxwrk , &
     &        minwrk , n , nerrs , nmax , nptknt , ntestt
      DOUBLE PRECISION abnorm , anorm , bnorm , ratio1 , ratio2 ,       &
     &                 thrsh2 , ulp , ulpinv
!     ..
!     .. Local Arrays ..
      COMPLEX*16 weight(5)
!     ..
!     .. External Functions ..
      INTEGER ILAENV
      DOUBLE PRECISION DLAMCH , ZLANGE
      EXTERNAL ILAENV , DLAMCH , ZLANGE
!     ..
!     .. External Subroutines ..
      EXTERNAL ALASVM , XERBLA , ZGET52 , ZGGEVX , ZLACPY , ZLATM6
!     ..
!     .. Intrinsic Functions ..
      INTRINSIC ABS , DCMPLX , MAX , SQRT
!     ..
!     .. Executable Statements ..
!
!     Check for errors
!
      Info = 0
!
      nmax = 5
!
      IF ( Nsize<0 ) THEN
         Info = -1
      ELSEIF ( Thresh<ZERO ) THEN
         Info = -2
      ELSEIF ( Nin<=0 ) THEN
         Info = -3
      ELSEIF ( Nout<=0 ) THEN
         Info = -4
      ELSEIF ( Lda<1 .OR. Lda<nmax ) THEN
         Info = -6
      ELSEIF ( Liwork<nmax+2 ) THEN
         Info = -26
      ENDIF
!
!     Compute workspace
!      (Note: Comments in the code beginning "Workspace:" describe the
!       minimal amount of workspace needed at that point in the code,
!       as well as the preferred amount for good performance.
!       NB refers to the optimal block size for the immediately
!       following subroutine, as returned by ILAENV.)
!
      minwrk = 1
      IF ( Info==0 .AND. Lwork>=1 ) THEN
         minwrk = 2*nmax*(nmax+1)
         maxwrk = nmax*(1+ILAENV(1,'ZGEQRF',' ',nmax,1,nmax,0))
         maxwrk = MAX(maxwrk,2*nmax*(nmax+1))
         Work(1) = maxwrk
      ENDIF
!
      IF ( Lwork<minwrk ) Info = -23
!
      IF ( Info/=0 ) THEN
         CALL XERBLA('ZDRGVX',-Info)
         RETURN
      ENDIF
!
      n = 5
      ulp = DLAMCH('P')
      ulpinv = ONE/ulp
      thrsh2 = TEN*Thresh
      nerrs = 0
      nptknt = 0
      ntestt = 0
!
      IF ( Nsize==0 ) THEN
         DO
!
!
!     Read in data from file to check accuracy of condition estimation
!     Read input data until N=0
!
            READ (Nin,FMT=*,END=100) n
            IF ( n==0 ) EXIT
            DO i = 1 , n
               READ (Nin,FMT=*) (A(i,j),j=1,n)
            ENDDO
            DO i = 1 , n
               READ (Nin,FMT=*) (B(i,j),j=1,n)
            ENDDO
            READ (Nin,FMT=*) (Dtru(i),i=1,n)
            READ (Nin,FMT=*) (Diftru(i),i=1,n)
!
            nptknt = nptknt + 1
!
!     Compute eigenvalues/eigenvectors of (A, B).
!     Compute eigenvalue/eigenvector condition numbers
!     using computed eigenvectors.
!
            CALL ZLACPY('F',n,n,A,Lda,Ai,Lda)
            CALL ZLACPY('F',n,n,B,Lda,Bi,Lda)
!
            CALL ZGGEVX('N','V','V','B',n,Ai,Lda,Bi,Lda,Alpha,Beta,Vl,  &
     &                  Lda,Vr,Lda,Ilo,Ihi,Lscale,Rscale,anorm,bnorm,S, &
     &                  Dif,Work,Lwork,Rwork,Iwork,Bwork,linfo)
!
            IF ( linfo/=0 ) THEN
               WRITE (Nout,FMT=99013) 'ZGGEVX' , linfo , n , nptknt
               CYCLE
            ENDIF
!
!     Compute the norm(A, B)
!
            CALL ZLACPY('Full',n,n,Ai,Lda,Work,n)
            CALL ZLACPY('Full',n,n,Bi,Lda,Work(n*n+1),n)
            abnorm = ZLANGE('Fro',n,2*n,Work,n,Rwork)
!
!     Tests (1) and (2)
!
            Result(1) = ZERO
            CALL ZGET52(.TRUE.,n,A,Lda,B,Lda,Vl,Lda,Alpha,Beta,Work,    &
     &                  Rwork,Result(1))
            IF ( Result(2)>Thresh ) WRITE (Nout,FMT=99014) 'Left' ,     &
     &           'ZGGEVX' , Result(2) , n , nptknt
!
            Result(2) = ZERO
            CALL ZGET52(.FALSE.,n,A,Lda,B,Lda,Vr,Lda,Alpha,Beta,Work,   &
     &                  Rwork,Result(2))
            IF ( Result(3)>Thresh ) WRITE (Nout,FMT=99014) 'Right' ,    &
     &           'ZGGEVX' , Result(3) , n , nptknt
!
!     Test (3)
!
            Result(3) = ZERO
            DO i = 1 , n
               IF ( S(i)==ZERO ) THEN
                  IF ( Dtru(i)>abnorm*ulp ) Result(3) = ulpinv
               ELSEIF ( Dtru(i)==ZERO ) THEN
                  IF ( S(i)>abnorm*ulp ) Result(3) = ulpinv
               ELSE
                  Rwork(i) = MAX(ABS(Dtru(i)/S(i)),ABS(S(i)/Dtru(i)))
                  Result(3) = MAX(Result(3),Rwork(i))
               ENDIF
            ENDDO
!
!     Test (4)
!
            Result(4) = ZERO
            IF ( Dif(1)==ZERO ) THEN
               IF ( Diftru(1)>abnorm*ulp ) Result(4) = ulpinv
            ELSEIF ( Diftru(1)==ZERO ) THEN
               IF ( Dif(1)>abnorm*ulp ) Result(4) = ulpinv
            ELSEIF ( Dif(5)==ZERO ) THEN
               IF ( Diftru(5)>abnorm*ulp ) Result(4) = ulpinv
            ELSEIF ( Diftru(5)==ZERO ) THEN
               IF ( Dif(5)>abnorm*ulp ) Result(4) = ulpinv
            ELSE
               ratio1 = MAX(ABS(Diftru(1)/Dif(1)),ABS(Dif(1)/Diftru(1)))
               ratio2 = MAX(ABS(Diftru(5)/Dif(5)),ABS(Dif(5)/Diftru(5)))
               Result(4) = MAX(ratio1,ratio2)
            ENDIF
!
            ntestt = ntestt + 4
!
!     Print out tests which fail.
!
            DO j = 1 , 4
               IF ( Result(j)>=thrsh2 ) THEN
!
!           If this is the first test to fail,
!           print a header to the data file.
!
                  IF ( nerrs==0 ) THEN
                     WRITE (Nout,FMT=99003) 'ZXV'
!
!              Print out messages for built-in examples
!
!              Matrix types
!
                     WRITE (Nout,FMT=99004)
!
!              Tests performed
!
                     WRITE (Nout,FMT=99008) '''' , 'transpose' , ''''
!
                  ENDIF
                  nerrs = nerrs + 1
                  IF ( Result(j)<10000.0D0 ) THEN
                     WRITE (Nout,FMT=99011) nptknt , n , j , Result(j)
                  ELSE
                     WRITE (Nout,FMT=99012) nptknt , n , j , Result(j)
                  ENDIF
               ENDIF
!
!
            ENDDO
         ENDDO
      ELSE
!
!     Parameters used for generating test matrices.
!
         weight(1) = DCMPLX(TNTH,ZERO)
         weight(2) = DCMPLX(HALF,ZERO)
         weight(3) = ONE
         weight(4) = ONE/weight(2)
         weight(5) = ONE/weight(1)
!
         DO iptype = 1 , 2
            DO iwa = 1 , 5
               DO iwb = 1 , 5
                  DO iwx = 1 , 5
                     DO iwy = 1 , 5
!
!                    generated a pair of test matrix
!
                        CALL ZLATM6(iptype,5,A,Lda,B,Vr,Lda,Vl,Lda,     &
     &                              weight(iwa),weight(iwb),weight(iwx),&
     &                              weight(iwy),Dtru,Diftru)
!
!                    Compute eigenvalues/eigenvectors of (A, B).
!                    Compute eigenvalue/eigenvector condition numbers
!                    using computed eigenvectors.
!
                        CALL ZLACPY('F',n,n,A,Lda,Ai,Lda)
                        CALL ZLACPY('F',n,n,B,Lda,Bi,Lda)
!
                        CALL ZGGEVX('N','V','V','B',n,Ai,Lda,Bi,Lda,    &
     &                              Alpha,Beta,Vl,Lda,Vr,Lda,Ilo,Ihi,   &
     &                              Lscale,Rscale,anorm,bnorm,S,Dif,    &
     &                              Work,Lwork,Rwork,Iwork,Bwork,linfo)
                        IF ( linfo/=0 ) THEN
                           WRITE (Nout,FMT=99001) 'ZGGEVX' , linfo , n ,&
     &                            iptype , iwa , iwb , iwx , iwy
                           CYCLE
                        ENDIF
!
!                    Compute the norm(A, B)
!
                        CALL ZLACPY('Full',n,n,Ai,Lda,Work,n)
                        CALL ZLACPY('Full',n,n,Bi,Lda,Work(n*n+1),n)
                        abnorm = ZLANGE('Fro',n,2*n,Work,n,Rwork)
!
!                    Tests (1) and (2)
!
                        Result(1) = ZERO
                        CALL ZGET52(.TRUE.,n,A,Lda,B,Lda,Vl,Lda,Alpha,  &
     &                              Beta,Work,Rwork,Result(1))
                        IF ( Result(2)>Thresh ) WRITE (Nout,FMT=99002)  &
     &                        'Left' , 'ZGGEVX' , Result(2) , n ,       &
     &                       iptype , iwa , iwb , iwx , iwy
!
                        Result(2) = ZERO
                        CALL ZGET52(.FALSE.,n,A,Lda,B,Lda,Vr,Lda,Alpha, &
     &                              Beta,Work,Rwork,Result(2))
                        IF ( Result(3)>Thresh ) WRITE (Nout,FMT=99002)  &
     &                        'Right' , 'ZGGEVX' , Result(3) , n ,      &
     &                       iptype , iwa , iwb , iwx , iwy
!
!                    Test (3)
!
                        Result(3) = ZERO
                        DO i = 1 , n
                           IF ( S(i)==ZERO ) THEN
                              IF ( Dtru(i)>abnorm*ulp ) Result(3)       &
     &                             = ulpinv
                           ELSEIF ( Dtru(i)==ZERO ) THEN
                              IF ( S(i)>abnorm*ulp ) Result(3) = ulpinv
                           ELSE
                              Rwork(i)                                  &
     &                           = MAX(ABS(Dtru(i)/S(i)),ABS(S(i)/Dtru  &
     &                           (i)))
                              Result(3) = MAX(Result(3),Rwork(i))
                           ENDIF
                        ENDDO
!
!                    Test (4)
!
                        Result(4) = ZERO
                        IF ( Dif(1)==ZERO ) THEN
                           IF ( Diftru(1)>abnorm*ulp ) Result(4)        &
     &                          = ulpinv
                        ELSEIF ( Diftru(1)==ZERO ) THEN
                           IF ( Dif(1)>abnorm*ulp ) Result(4) = ulpinv
                        ELSEIF ( Dif(5)==ZERO ) THEN
                           IF ( Diftru(5)>abnorm*ulp ) Result(4)        &
     &                          = ulpinv
                        ELSEIF ( Diftru(5)==ZERO ) THEN
                           IF ( Dif(5)>abnorm*ulp ) Result(4) = ulpinv
                        ELSE
                           ratio1 = MAX(ABS(Diftru(1)/Dif(1)),          &
     &                              ABS(Dif(1)/Diftru(1)))
                           ratio2 = MAX(ABS(Diftru(5)/Dif(5)),          &
     &                              ABS(Dif(5)/Diftru(5)))
                           Result(4) = MAX(ratio1,ratio2)
                        ENDIF
!
                        ntestt = ntestt + 4
!
!                    Print out tests which fail.
!
                        DO j = 1 , 4
                           IF ( (Result(j)>=thrsh2 .AND. j>=4) .OR.     &
     &                          (Result(j)>=Thresh .AND. j<=3) ) THEN
!
!                       If this is the first test to fail,
!                       print a header to the data file.
!
                              IF ( nerrs==0 ) THEN
                                 WRITE (Nout,FMT=99003) 'ZXV'
!
!                          Print out messages for built-in examples
!
!                          Matrix types
!
                                 WRITE (Nout,FMT=99005)
                                 WRITE (Nout,FMT=99006)
                                 WRITE (Nout,FMT=99007)
!
!                          Tests performed
!
                                 WRITE (Nout,FMT=99008) '''' ,          &
     &                                  'transpose' , ''''
!
                              ENDIF
                              nerrs = nerrs + 1
                              IF ( Result(j)<10000.0D0 ) THEN
                                 WRITE (Nout,FMT=99009) iptype , iwa ,  &
     &                                  iwb , iwx , iwy , j , Result(j)
                              ELSE
                                 WRITE (Nout,FMT=99010) iptype , iwa ,  &
     &                                  iwb , iwx , iwy , j , Result(j)
                              ENDIF
                           ENDIF
                        ENDDO
!
!
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
!
         ENDDO
      ENDIF
!
!     Summary
!
 100  CALL ALASVM('ZXV',Nout,nerrs,ntestt,0)
!
      Work(1) = maxwrk
!
      RETURN
!
99001 FORMAT (' ZDRGVX: ',A,' returned INFO=',I6,'.',/9X,'N=',I6,       &
     &        ', JTYPE=',I6,')')
!
99002 FORMAT (' ZDRGVX: ',A,' Eigenvectors from ',A,' incorrectly ',    &
     &        'normalized.',/' Bits of error=',0P,G10.3,',',9X,'N=',I6, &
     &        ', JTYPE=',I6,', IWA=',I5,', IWB=',I5,', IWX=',I5,        &
     &        ', IWY=',I5)
!
99003 FORMAT (/1X,A3,' -- Complex Expert Eigenvalue/vector',            &
     &        ' problem driver')
!
99004 FORMAT ('Input Example')
!
99005 FORMAT (' Matrix types: ',/)
!
99006 FORMAT (' TYPE 1: Da is diagonal, Db is identity, ',              &
     &        /'     A = Y^(-H) Da X^(-1), B = Y^(-H) Db X^(-1) ',      &
     &        /'     YH and X are left and right eigenvectors. ',/)
!
99007 FORMAT (' TYPE 2: Da is quasi-diagonal, Db is identity, ',        &
     &        /'     A = Y^(-H) Da X^(-1), B = Y^(-H) Db X^(-1) ',      &
     &        /'     YH and X are left and right eigenvectors. ',/)
!
99008 FORMAT (/' Tests performed:  ',/4X,                               &
     &        ' a is alpha, b is beta, l is a left eigenvector, ',/4X,  &
     &        ' r is a right eigenvector and ',A,' means ',A,'.',       &
     &        /' 1 = max | ( b A - a B )',A,' l | / const.',            &
     &        /' 2 = max | ( b A - a B ) r | / const.',                 &
     &        /' 3 = max ( Sest/Stru, Stru/Sest ) ',                    &
     &        ' over all eigenvalues',                                  &
     &        /' 4 = max( DIFest/DIFtru, DIFtru/DIFest ) ',             &
     &        ' over the 1st and 5th eigenvectors',/)
!
99009 FORMAT (' Type=',I2,',',' IWA=',I2,', IWB=',I2,', IWX=',I2,       &
     &        ', IWY=',I2,', result ',I2,' is',0P,F8.2)
!
99010 FORMAT (' Type=',I2,',',' IWA=',I2,', IWB=',I2,', IWX=',I2,       &
     &        ', IWY=',I2,', result ',I2,' is',1P,D10.3)
!
99011 FORMAT (' Input example #',I2,', matrix order=',I4,',',' result ',&
     &        I2,' is',0P,F8.2)
!
99012 FORMAT (' Input example #',I2,', matrix order=',I4,',',' result ',&
     &        I2,' is',1P,D10.3)
!
99013 FORMAT (' ZDRGVX: ',A,' returned INFO=',I6,'.',/9X,'N=',I6,       &
     &        ', Input example #',I2,')')
!
99014 FORMAT (' ZDRGVX: ',A,' Eigenvectors from ',A,' incorrectly ',    &
     &        'normalized.',/' Bits of error=',0P,G10.3,',',9X,'N=',I6, &
     &        ', Input Example #',I2,')')
!
!     End of ZDRGVX
!
      END SUBROUTINE ZDRGVX
